)
#' @rdname create.survey.results-methods
#' @export
setMethod(
f="create.survey.results",
signature="Simulation",
definition=function(object, dht.tables = FALSE, ...){
population <- generate.population(object)
transects  <- generate.transects(object)
if(object@double.observer){
#move this to the checking of the simulation object
message("Double observer simulations not supported at present")
}else{
if(inherits(object@design, "LT.Design")){
survey <- new(Class = "Single.Obs.LT.Survey", population = population, line.transect = transects, perp.truncation = object@detectability@truncation)
}else if(inherits(object@design, "PT.Design")){
survey <- new(Class = "Single.Obs.PT.Survey", population = population, point.transect = transects, rad.truncation = object@detectability@truncation)
}
}
survey.data <- create.survey.results(object = survey, dht.tables = dht.tables, region = object@region)
ddf.data <- survey.data$ddf.data
if(dht.tables){
obs.table <- survey.data$obs.table
sample.table <- survey.data$sample.table
region.table <- survey.data$region.table
survey.results <- new(Class = "Survey.Results", region = object@region, population = population, transects = transects, ddf.data = ddf.data, obs.table = obs.table, sample.table = sample.table, region.table = region.table)
}else{
obs.table <- new(Class = "Obs.Table")
sample.table <- new(Class = "Sample.Table")
region.table <- new(Class = "Region.Table")
survey.results <- new(Class = "Survey.Results", region = object@region, population = population, transects = transects, ddf.data = ddf.data, obs.table = obs.table, sample.table = sample.table, region.table = region.table)
}
return(survey.results)
}
)
#' @rdname run.analysis-methods
#' @export
setMethod(
f="run.analysis",
signature=c("Simulation","Survey.Results"),
definition=function(object, data, dht = FALSE){
#dist.data <- survey.results@ddf.data
best.model <- run.analysis(object, data@ddf.data)
#If dht is true but tables have not been provided
if(dht & nrow(data@region.table@region.table) == 0){
warning("dht tables have not been provided please re-run create.survey.results with dht.tables = TRUE if you would like density/abundance estimates in addition to ddf results.", immediate. = TRUE, call. = FALSE)
dht = FALSE
}
#If ddf has converged and dht it TRUE
if(dht & !is.null(best.model)){
#Calculate density/abundance
dht.results <- dht(best.model, data@region.table@region.table, data@sample.table@sample.table, data@obs.table@obs.table)
return(list(ddf = best.model, dht = dht.results))
}
return(list(ddf = best.model))
}
)
#' @rdname run.analysis-methods
#' @importFrom stats na.omit
#' @export
setMethod(
f="run.analysis",
signature=c("Simulation","DDF.Data"),
definition=function(object, data, dht = FALSE){
ddf.analyses <- object@ddf.analyses
criteria <- NULL
results <- list()
point <- inherits(object@design, "PT.Design")
for(a in seq(along = ddf.analyses)){
results[[a]] <- run.analysis(ddf.analyses[[a]], data, point = point)
if(!is.na(results[[a]][1])){
#Get information to calculate selection criteria
lnl <- results[[a]]$lnl
k <- length(results[[a]]$par)
n <- nrow(results[[a]]$data)
criterion <- object@ddf.analyses[[1]]@criteria
selection.criterion.value <- switch(criterion,
AIC  = 2*k-2*lnl,
aic  = 2*k-2*lnl,
AICc = 2*k-2*lnl+(2*k*(k+1))/(n-k-1),
BIC  = k*log(n)-2*lnl,
bic  = k*log(n)-2*lnl)
criteria <- c(criteria, selection.criterion.value)
}else{
criteria <- c(criteria, NA)
}
}
#check that at least one model worked
no.successful.models <- length(which(!is.na(criteria)))
if(no.successful.models > 0){
best.model.index <- which(criteria == min(na.omit(criteria)))
best.model <- results[[best.model.index]]
best.model$model.index <- best.model.index
#If there is more than one sucessful model find the delta criteria to the
#second best model.
if(no.successful.models > 1){
sorted.criteria <- sort(criteria, na.last = NA)
delta.criteria <- sorted.criteria[2] - sorted.criteria[1]
best.model$delta.criteria <- delta.criteria
}
return(best.model)
}else{
return(NULL)
}
}
)
#' @rdname run-methods
#' @importFrom parallel detectCores makeCluster clusterEvalQ parLapply stopCluster
#' @export
setMethod(
f="run",
signature="Simulation",
definition=function(object, run.parallel = FALSE, max.cores = NA, save.data = FALSE, load.data = FALSE, data.path = character(0)){
#Note options save.data, load.data, data.path are not implemented in simulations run in parallel.
#check the data.path ends in "/"
if(length(data.path) > 0){
temp.path <- strsplit(data.path, split = "")
if(temp.path[length(temp.path)] != "/"){
data.path <- paste(data.path, "/", sep = "")
}
rm(temp.path)
}
#set the transect index to 1
orig.file.index <- object@design@file.index
object@design@file.index <- 1
if(run.parallel & requireNamespace('parallel', quietly = TRUE)){
# counts the number of cores you have
nCores <- getOption("cl.cores", detectCores())
if(!is.na(max.cores)){
nCores <- min(nCores - 1, max.cores)
}
# intitialise the cluster
myCluster <- makeCluster(nCores)
clusterEvalQ(myCluster, {
require(DSsim)
})
results <- parLapply(myCluster, X = as.list(1:object@reps), fun = single.simulation.loop, object = object, save.data = save.data, load.data = load.data, data.path = data.path)
object <- accumulate.PP.results(simulation = object, results = results)
stopCluster(myCluster)
}else{
#Check that it wasn't trying to run parallel
if(run.parallel){
warning("Could not run in parallel, library(parallel) is not installed.")
}
#otherwise loop
for(i in 1:object@reps){
object@results <- single.simulation.loop(i, object, save.data = save.data, load.data = load.data, data.path = data.path)
}
}
object@results <- add.summary.results(object@results)
object@design@file.index <- orig.file.index
return(object)
}
)
library(DSsim)
summary(sim.trunc125.aic.hnhr)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
summary(sim.trunc125.aic.hnhr)
summary(sim, include.glossary=FALSE)
sim.trunc125.aic.hnhr@results$individuals$N
sim.trunc125.aic.hnhr@results$individuals$summary
sim.trunc125.aic.hnhr@results
sim.trunc125.aic.hnhr@results$Detection
sim.trunc125.aic.hnhr@results
sim.trunc125.aic.hnhr@results$individuals
sim.trunc125.aic.hnhr@results$individuals$N
sim.trunc125.aic.hnhr@results$individuals$N[1,,]
sim.trunc125.aic.hnhr@results$individuals$N[1,,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,4,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,5,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,1,1000]
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
sim.trunc125.aic.hnhr
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc150AIChnhr.robj")
length(sim.trunc125.aic.hnhr@results$individuals$N[1,1,1:999])
summary(sims[[1]])
summary(sims[[1]])```
??ggplot
install.packages("ggplot2")
data = data.frame(truncation = c(125, 150, 175, 200, 250, 300), estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999])
)
?stat_summary
library(DSsim)
library(ggplot2)
data = data.frame(truncation = factor(rep(c(125, 150, 175, 200, 250, 300), each=999)), estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999]))
ggplot(data, aes(x = truncation, y = estimates))
+ geom_boxplot()
+ geom_hline(yintercept = 250, linetype="dashed", color = "red", size = 1.2)
+ stat_summary(fun.y = mean, geom="point", size = 2, color = "blue")
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
library(DSsim)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc150AIChnhr.robj")
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc1775AIChnhr.robj")
sims<-vector("list", length=2)
sims[[1]] <- sim.trunc125.aic.hnhr
sims[[2]] <- sim
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
Trunc.Dist = extract.trun.dist(sims)
?lapply
Trunc.dist <- lapply(sims, extract.trun.dist)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
# Chunk 1
library(DSsim)
library(shapefiles)
set.seed(321)
# Chunk 2
region.shapefile <- read.shapefile("Study_ar")
region <- make.region(region.name = "Survey Region", units = "m", shapefile = region.shapefile)
plot(region)
# Chunk 3
pop.density <- make.density(region = region, x.space = 1000, y.space = 1000, constant = 1)
plot(pop.density, plot.units = "km", style = "blocks")
plot(region, add = TRUE)
# Chunk 4
pop.description <- make.population.description(region.obj = region, density.obj = pop.density, N = 250, fixed.N = TRUE)
# Chunk 5
detect <- make.detectability(key.function = "hn", scale.param = 100, truncation = 500)
# Chunk 6
parallel.design <- make.design(transect.type = "Line",design.details = c("Parallel","Systematic"),region.obj = region, path = "shapefiles")
# Chunk 7
sigma = 100
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = 1.25*sigma)
# Chunk 8
simtrunc125 <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
# Chunk 9
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 10
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 11
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 12
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 13
simtrunc125 <- run(simtrunc125)
# Chunk 14
Trun.dists <- c(1.25*sigma, 1.5*sigma, 1.75*sigma, 2*sigma, 2.5*sigma, 3*sigma)
sims <- vector("list", length(Trun.dists))
sims[[1]]<-simtrunc125
for(i in 2:6){
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = Trun.dists[[i]])
sim <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
sim  <- run(sim)
sims[[i]]<-sim
}
# Chunk 16
library(xtable)
# Chunk 17
extract.N <- function(simulation){
return(simulation@population.description@N)
}
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
Trunc.Dist <- lapply(sims, extract.trun.dist)
extract.n <- function(simulation){
return(simulation@results$individuals$summary[1,4,1000])
}
n <- lapply(sims, extract.n)
extract.est.abund <- function(simulation){
return(simulation@results$individuals$summary[1,1,1000])
}
Est.Abund <- lapply(sims, extract.est.abund)
extract.mean.se <- function(simulation){
return(simulation@results$individuals$summary[1,2,1000])
}
mean.se <- lapply(sims, extract.mean.se)
extract.perc.bias <- function(simulation){
N <- extract.N(simulation)
Est.Abund <- extract.est.abund(simulation)
return(100*(Est.Abund-N)/N)
}
Perc.Bias <- lapply(sims, extract.perc.bias)
extract.RMSE <- function(simulation){
N <- extract.N(simulation)
reps <- simulation@reps
}
RMSE = rep(NA, 6)
for(i in 1:length(sims)){ RMSE[i] = sqrt(sum((sims[[i]]@results$individuals$N[1,1,1:999]-250)**2)/999)
}
Model.selection <- function(simulation){
sum = 0
for(x in simulation@results$Detection[1,5,1:999]){
if(!is.na(x) && x=="2"){
sum=sum+1
}
}
return(c(999-sum, sum))
}
model.selection.numbers = rep(NA, 6)
for(i in 1:length(sims)){
model.selection.numbers[i] = Model.selection(sims[[i]])[1]
}
perc.correct.selection = rep(NA, 6)
for(i in 1:length(sims)){
perc.correct.selection[i]=100*model.selection.numbers[i]/999
}
simulation.data = data.frame( Trunc.Dist = Trunc.Dist, n=n, Est.Abund = Est.Abund, mean.se = mean.se, Perc.Bias = Perc.Bias, RMSE=RMSE, Correct.Select = perc.correct.selection)
table<-xtable(simulation.data, label = "Table", align = c('c', 'c', 'c', 'c', 'c', 'c', 'c', 'c'), digits = c(0, 0, 0, 2, 2, 2, 2, 2))
colnames(table) <- c("$Trunc Dist$", "$n$", "$Mean \\hat{N}$", "$SE$", "$\\% Bias$", "$RMSE$", "$\\% Correct Select$")
print(table, floating=TRUE, include.rownames = FALSE, NA.string="NA", caption = "Simulation Results", caption.placement="top", table.placement="!h", sanitize.colnames.function = identity, latex.environments="center", type = "html")
# Chunk 18
plot(Trunc.Dist, RMSE)
# Chunk 19
library(ggplot2)
data = data.frame(Truncation = factor(rep(c(125, 150, 175, 200, 250, 300), each=999)), Estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999]))
ggplot(data, aes(x = Truncation, y = Estimates)) + geom_boxplot() + geom_hline(yintercept = 250, linetype="dashed", color = "red", size = 1.2) + stat_summary(fun.y = mean, geom="point", size = 2, color = "blue")
# Chunk 1
library(DSsim)
library(shapefiles)
set.seed(321)
# Chunk 2
region.shapefile <- read.shapefile("Study_ar")
region <- make.region(region.name = "Survey Region", units = "m", shapefile = region.shapefile)
plot(region)
# Chunk 3
pop.density <- make.density(region = region, x.space = 1000, y.space = 1000, constant = 1)
plot(pop.density, plot.units = "km", style = "blocks")
plot(region, add = TRUE)
# Chunk 4
pop.description <- make.population.description(region.obj = region, density.obj = pop.density, N = 250, fixed.N = TRUE)
# Chunk 5
detect <- make.detectability(key.function = "hn", scale.param = 100, truncation = 500)
# Chunk 6
parallel.design <- make.design(transect.type = "Line",design.details = c("Parallel","Systematic"),region.obj = region, path = "shapefiles")
# Chunk 7
sigma = 100
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = 1.25*sigma)
# Chunk 8
simtrunc125 <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
# Chunk 9
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 10
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 11
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 12
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 13
simtrunc125 <- run(simtrunc125)
# Chunk 14
Trun.dists <- c(1.25*sigma, 1.5*sigma, 1.75*sigma, 2*sigma, 2.5*sigma, 3*sigma)
sims <- vector("list", length(Trun.dists))
sims[[1]]<-simtrunc125
for(i in 2:6){
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = Trun.dists[[i]])
sim <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
sim  <- run(sim)
sims[[i]]<-sim
}
# Chunk 16
library(xtable)
# Chunk 17
extract.N <- function(simulation){
return(simulation@population.description@N)
}
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
Trunc.Dist <- lapply(sims, extract.trun.dist)
extract.n <- function(simulation){
return(simulation@results$individuals$summary[1,4,1000])
}
n <- lapply(sims, extract.n)
extract.est.abund <- function(simulation){
return(simulation@results$individuals$summary[1,1,1000])
}
Est.Abund <- lapply(sims, extract.est.abund)
extract.mean.se <- function(simulation){
return(simulation@results$individuals$summary[1,2,1000])
}
mean.se <- lapply(sims, extract.mean.se)
extract.perc.bias <- function(simulation){
N <- extract.N(simulation)
Est.Abund <- extract.est.abund(simulation)
return(100*(Est.Abund-N)/N)
}
Perc.Bias <- lapply(sims, extract.perc.bias)
extract.RMSE <- function(simulation){
N <- extract.N(simulation)
reps <- simulation@reps
}
RMSE = rep(NA, 6)
for(i in 1:length(sims)){ RMSE[i] = sqrt(sum((sims[[i]]@results$individuals$N[1,1,1:999]-250)**2)/999)
}
Model.selection <- function(simulation){
sum = 0
for(x in simulation@results$Detection[1,5,1:999]){
if(!is.na(x) && x=="2"){
sum=sum+1
}
}
return(c(999-sum, sum))
}
model.selection.numbers = rep(NA, 6)
for(i in 1:length(sims)){
model.selection.numbers[i] = Model.selection(sims[[i]])[1]
}
perc.correct.selection = rep(NA, 6)
for(i in 1:length(sims)){
perc.correct.selection[i]=100*model.selection.numbers[i]/999
}
simulation.data = data.frame( Trunc.Dist = Trunc.Dist, n=n, Est.Abund = Est.Abund, mean.se = mean.se, Perc.Bias = Perc.Bias, RMSE=RMSE, Correct.Select = perc.correct.selection)
table<-xtable(simulation.data, label = "Table", align = c('c', 'c', 'c', 'c', 'c', 'c', 'c', 'c'), digits = c(0, 0, 0, 2, 2, 2, 2, 2))
colnames(table) <- c("$Trunc Dist$", "$n$", "$Mean \\hat{N}$", "$SE$", "$\\% Bias$", "$RMSE$", "$\\% Correct Select$")
print(table, floating=TRUE, include.rownames = FALSE, NA.string="NA", caption = "Simulation Results", caption.placement="top", table.placement="!h", sanitize.colnames.function = identity, latex.environments="center", type = "html")
# Chunk 18
plot(Trunc.Dist, RMSE)
# Chunk 19
library(ggplot2)
data = data.frame(Truncation = factor(rep(c(125, 150, 175, 200, 250, 300), each=999)), Estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999]))
ggplot(data, aes(x = Truncation, y = Estimates)) + geom_boxplot() + geom_hline(yintercept = 250, linetype="dashed", color = "red", size = 1.2) + stat_summary(fun.y = mean, geom="point", size = 2, color = "blue")
setwd("~/GitHub/DSsim/DSsim/vignettes")
# Chunk 1
library(DSsim)
library(shapefiles)
set.seed(321)
# Chunk 2
region.shapefile <- read.shapefile("Study_ar")
region <- make.region(region.name = "Survey Region", units = "m", shapefile = region.shapefile)
plot(region)
# Chunk 3
pop.density <- make.density(region = region, x.space = 1000, y.space = 1000, constant = 1)
plot(pop.density, plot.units = "km", style = "blocks")
plot(region, add = TRUE)
# Chunk 4
pop.description <- make.population.description(region.obj = region, density.obj = pop.density, N = 250, fixed.N = TRUE)
# Chunk 5
detect <- make.detectability(key.function = "hn", scale.param = 100, truncation = 500)
# Chunk 6
parallel.design <- make.design(transect.type = "Line",design.details = c("Parallel","Systematic"),region.obj = region, path = "shapefiles")
# Chunk 7
sigma = 100
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = 1.25*sigma)
# Chunk 8
simtrunc125 <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
# Chunk 9
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 10
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 11
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 12
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 13
simtrunc125 <- run(simtrunc125)
# Chunk 14
Trun.dists <- c(1.25*sigma, 1.5*sigma, 1.75*sigma, 2*sigma, 2.5*sigma, 3*sigma)
sims <- vector("list", length(Trun.dists))
sims[[1]]<-simtrunc125
for(i in 2:6){
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = Trun.dists[[i]])
sim <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
sim  <- run(sim)
sims[[i]]<-sim
}
sim.trunc125.aic.hnhr@results$individuals$N[1,1,555]
sim.trunc125.aic.hnhr@results$individuals$N[1,1,400:600]
simtrunc125@results$individuals$N[1,1,]
summary(simtrunc125)
simtrunc125@results$individuals$N[1,4,555]
simtrunc125@results$individuals$N[1,4,556]
simtrunc125@results$individuals$N[1,4,555]
simtrunc125@results$individuals$N[1,4,554]
simtrunc125@results$individuals$N[1,4,555]
simtrunc125@results$individuals$N[1,,555]
simtrunc125@results$individuals$N[,,555]
simtrunc125@results$individuals[,,555]
simtrunc125@results$individuals
simtrunc125@results$individuals[,,554:556]
simtrunc125@results$individuals[, , 554:556]
simtrunc125@results$individuals[,1, 554:556]
simtrunc125@results$individuals[555]
simtrunc125@results[,,555]
simtrunc125@results[,,556]
simtrunc125@results
simtrunc125@results$filename
simtrunc125@results$Detection
simtrunc125@results$Detection[,,555]
sim@results$individuals$N[1,4,555]
sims[[3@results$individuals$N[1,4,555]
]]
sims[[3]]@results$individuals$N[1,4,555]
sims[[3]]@results$individuals$N[1,4,554]
sims[[3]]@results$individuals$N[1,4,555]
sims[[2]]@results$individuals$N[1,4,555]
sims[[4]]@results$individuals$N[1,4,555]
sims[[5]]@results$individuals$N[1,4,555]
sims[[6]]@results$individuals$N[1,4,555]
sims[[2]]@results$individuals$N[1,4,555]
