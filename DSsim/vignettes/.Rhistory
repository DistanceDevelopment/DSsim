#' @export
setMethod(
f="show",
signature="Simulation",
definition=function(object){
message("show not currently implemented")
invisible(object)
}
)
#' histogram.N.ests
#'
#' Plots a histogram of the estimates abundances
#'
#' @param x object of class Simulation
#' @param ... optional parameters to pass to the generic hist function in graphics
#' @rdname histogram.N.ests-methods
#' @importFrom graphics hist abline
#' @export
histogram.N.ests <- function(x, ...){
reps <- x@reps
index <- dim(x@results$individuals$N)[1]
true.N <- sum(x@population.description@N)
if(!is.null(x@results$clusters)){
ests <- x@results$clusters$N[index, "Estimate", 1:reps]
hist(ests, main = "Histogram of Estimates", xlab = "Estimated Abundance of Clusters", ...)
}else{
ests <- x@results$individuals$N[index, "Estimate", 1:reps]
hist(ests, main = "Histogram of Estimates", xlab = "Estimated Abundance of Individuals", ...)
}
abline(v = true.N, col = 2, lwd = 3, lty = 2)
invisible(x)
}
# @rdname Simulation-class
# @export
#setMethod(
#  f="plot",
#  signature="Simulation",
#  definition=function(x, ...){
#    message("not currently implemented")
#    invisible(x)
#  }
#)
#' @rdname generate.population-methods
#' @export
setMethod(
f="generate.population",
signature="Simulation",
definition=function(object, ...){
population <- generate.population(object = object@population.description, detectability = object@detectability, region.obj = object@region)
return(population)
}
)
#' @rdname generate.transects-methods
#' @export
setMethod(
f="generate.transects",
signature="Simulation",
definition=function(object, read.from.file = TRUE, write.to.file = FALSE, region = NULL){
region <- object@region
transect <- generate.transects(object@design, region = region)
return(transect)
}
)
#' @rdname create.survey.results-methods
#' @export
setMethod(
f="create.survey.results",
signature="Simulation",
definition=function(object, dht.tables = FALSE, ...){
population <- generate.population(object)
transects  <- generate.transects(object)
if(object@double.observer){
#move this to the checking of the simulation object
message("Double observer simulations not supported at present")
}else{
if(inherits(object@design, "LT.Design")){
survey <- new(Class = "Single.Obs.LT.Survey", population = population, line.transect = transects, perp.truncation = object@detectability@truncation)
}else if(inherits(object@design, "PT.Design")){
survey <- new(Class = "Single.Obs.PT.Survey", population = population, point.transect = transects, rad.truncation = object@detectability@truncation)
}
}
survey.data <- create.survey.results(object = survey, dht.tables = dht.tables, region = object@region)
ddf.data <- survey.data$ddf.data
if(dht.tables){
obs.table <- survey.data$obs.table
sample.table <- survey.data$sample.table
region.table <- survey.data$region.table
survey.results <- new(Class = "Survey.Results", region = object@region, population = population, transects = transects, ddf.data = ddf.data, obs.table = obs.table, sample.table = sample.table, region.table = region.table)
}else{
obs.table <- new(Class = "Obs.Table")
sample.table <- new(Class = "Sample.Table")
region.table <- new(Class = "Region.Table")
survey.results <- new(Class = "Survey.Results", region = object@region, population = population, transects = transects, ddf.data = ddf.data, obs.table = obs.table, sample.table = sample.table, region.table = region.table)
}
return(survey.results)
}
)
#' @rdname run.analysis-methods
#' @export
setMethod(
f="run.analysis",
signature=c("Simulation","Survey.Results"),
definition=function(object, data, dht = FALSE){
#dist.data <- survey.results@ddf.data
best.model <- run.analysis(object, data@ddf.data)
#If dht is true but tables have not been provided
if(dht & nrow(data@region.table@region.table) == 0){
warning("dht tables have not been provided please re-run create.survey.results with dht.tables = TRUE if you would like density/abundance estimates in addition to ddf results.", immediate. = TRUE, call. = FALSE)
dht = FALSE
}
#If ddf has converged and dht it TRUE
if(dht & !is.null(best.model)){
#Calculate density/abundance
dht.results <- dht(best.model, data@region.table@region.table, data@sample.table@sample.table, data@obs.table@obs.table)
return(list(ddf = best.model, dht = dht.results))
}
return(list(ddf = best.model))
}
)
#' @rdname run.analysis-methods
#' @importFrom stats na.omit
#' @export
setMethod(
f="run.analysis",
signature=c("Simulation","DDF.Data"),
definition=function(object, data, dht = FALSE){
ddf.analyses <- object@ddf.analyses
criteria <- NULL
results <- list()
point <- inherits(object@design, "PT.Design")
for(a in seq(along = ddf.analyses)){
results[[a]] <- run.analysis(ddf.analyses[[a]], data, point = point)
if(!is.na(results[[a]][1])){
#Get information to calculate selection criteria
lnl <- results[[a]]$lnl
k <- length(results[[a]]$par)
n <- nrow(results[[a]]$data)
criterion <- object@ddf.analyses[[1]]@criteria
selection.criterion.value <- switch(criterion,
AIC  = 2*k-2*lnl,
aic  = 2*k-2*lnl,
AICc = 2*k-2*lnl+(2*k*(k+1))/(n-k-1),
BIC  = k*log(n)-2*lnl,
bic  = k*log(n)-2*lnl)
criteria <- c(criteria, selection.criterion.value)
}else{
criteria <- c(criteria, NA)
}
}
#check that at least one model worked
no.successful.models <- length(which(!is.na(criteria)))
if(no.successful.models > 0){
best.model.index <- which(criteria == min(na.omit(criteria)))
best.model <- results[[best.model.index]]
best.model$model.index <- best.model.index
#If there is more than one sucessful model find the delta criteria to the
#second best model.
if(no.successful.models > 1){
sorted.criteria <- sort(criteria, na.last = NA)
delta.criteria <- sorted.criteria[2] - sorted.criteria[1]
best.model$delta.criteria <- delta.criteria
}
return(best.model)
}else{
return(NULL)
}
}
)
#' @rdname run-methods
#' @importFrom parallel detectCores makeCluster clusterEvalQ parLapply stopCluster
#' @export
setMethod(
f="run",
signature="Simulation",
definition=function(object, run.parallel = FALSE, max.cores = NA, save.data = FALSE, load.data = FALSE, data.path = character(0)){
#Note options save.data, load.data, data.path are not implemented in simulations run in parallel.
#check the data.path ends in "/"
if(length(data.path) > 0){
temp.path <- strsplit(data.path, split = "")
if(temp.path[length(temp.path)] != "/"){
data.path <- paste(data.path, "/", sep = "")
}
rm(temp.path)
}
#set the transect index to 1
orig.file.index <- object@design@file.index
object@design@file.index <- 1
if(run.parallel & requireNamespace('parallel', quietly = TRUE)){
# counts the number of cores you have
nCores <- getOption("cl.cores", detectCores())
if(!is.na(max.cores)){
nCores <- min(nCores - 1, max.cores)
}
# intitialise the cluster
myCluster <- makeCluster(nCores)
clusterEvalQ(myCluster, {
require(DSsim)
})
results <- parLapply(myCluster, X = as.list(1:object@reps), fun = single.simulation.loop, object = object, save.data = save.data, load.data = load.data, data.path = data.path)
object <- accumulate.PP.results(simulation = object, results = results)
stopCluster(myCluster)
}else{
#Check that it wasn't trying to run parallel
if(run.parallel){
warning("Could not run in parallel, library(parallel) is not installed.")
}
#otherwise loop
for(i in 1:object@reps){
object@results <- single.simulation.loop(i, object, save.data = save.data, load.data = load.data, data.path = data.path)
}
}
object@results <- add.summary.results(object@results)
object@design@file.index <- orig.file.index
return(object)
}
)
library(DSsim)
summary(sim.trunc125.aic.hnhr)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
summary(sim.trunc125.aic.hnhr)
summary(sim, include.glossary=FALSE)
sim.trunc125.aic.hnhr@results$individuals$N
sim.trunc125.aic.hnhr@results$individuals$summary
sim.trunc125.aic.hnhr@results
sim.trunc125.aic.hnhr@results$Detection
sim.trunc125.aic.hnhr@results
sim.trunc125.aic.hnhr@results$individuals
sim.trunc125.aic.hnhr@results$individuals$N
sim.trunc125.aic.hnhr@results$individuals$N[1,,]
sim.trunc125.aic.hnhr@results$individuals$N[1,,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,4,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,5,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,1,1000]
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
sim.trunc125.aic.hnhr
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc150AIChnhr.robj")
length(sim.trunc125.aic.hnhr@results$individuals$N[1,1,1:999])
summary(sims[[1]])
summary(sims[[1]])```
??ggplot
install.packages("ggplot2")
data = data.frame(truncation = c(125, 150, 175, 200, 250, 300), estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999])
)
?stat_summary
library(DSsim)
library(ggplot2)
data = data.frame(truncation = factor(rep(c(125, 150, 175, 200, 250, 300), each=999)), estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999]))
ggplot(data, aes(x = truncation, y = estimates))
+ geom_boxplot()
+ geom_hline(yintercept = 250, linetype="dashed", color = "red", size = 1.2)
+ stat_summary(fun.y = mean, geom="point", size = 2, color = "blue")
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
library(DSsim)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc150AIChnhr.robj")
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc1775AIChnhr.robj")
sims<-vector("list", length=2)
sims[[1]] <- sim.trunc125.aic.hnhr
sims[[2]] <- sim
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
Trunc.Dist = extract.trun.dist(sims)
?lapply
Trunc.dist <- lapply(sims, extract.trun.dist)
library(knitr)
?kable
?switch
extract.info <- function(simulation, info.name){
switch(info.name,
N = simulation@population.description@N,
reps = simulation@reps,
truncation.distance = simulation@ddf.analyses[[1]]@truncation,
n = simulation@results$individuals$summary[1,4,1000],
estimated.abundance = simulation@results$individuals$N[1,1,1000],
mean.se = simulation@results$individuals$N[1,2,1000],
percentage.bias = 100*((simulation@results$individuals$N[1,1,1000] - simulation@population.description@N)/simulation@population.description@N),
RMSE = sqrt(sum((simulation@results$individuals$N[1,1,1:simulation@reps]-simulation@population.description@N)**2)/simulation@reps))
}
?lapply
?paste
?cbind
vignette(package = "Devtools")
vignette(package = "devtools")
vignette("dependencies", package = "devtools")
sims <- data(truncationResults.rda, package = DSsim)
sims <- data(truncationResults.rda, package = "DSsim")
sims <- load(truncationResults.rda, package = DSsim)
?load
library(DSsim)
data()
sims <- load(file = "~/GitHub/DSsim/DSsim/data/truncationResults.rda")
sims[[1]]
sims[2]
sims[1]
sims[1][1]
sims[1][]
sims[1][2]
sims[[1]]
sims[[1]]@reps
?save
sims <- load(file = "~/GitHub/DSsim/DSsim/data/truncationResultsAIC.rda")
sims <- load(file = "~/GitHub/DSsim/DSsim/data/truncationResultsBIC.rda")
load(file = "~/GitHub/DSsim/DSsim/data/truncationResultsBIC.rda")
?load
load(file = "~/GitHub/DSsim/DSsim/data/truncationResultsAIC.rda")
sims
extract.info <- function(simulation, info.name){
switch(info.name,
N = simulation@population.description@N,
reps = simulation@reps,
truncation.distance = simulation@ddf.analyses[[1]]@truncation,
n = simulation@results$individuals$summary[1,4,1000],
estimated.abundance = simulation@results$individuals$N[1,1,1000],
mean.se = simulation@results$individuals$N[1,2,1000],
percentage.bias = 100*((simulation@results$individuals$N[1,1,1000]
- simulation@population.description@N)
/simulation@population.description@N),
RMSE = sqrt(sum((simulation@results$individuals$N[1,1,1:simulation@reps]
- simulation@population.description@N)**2)/simulation@reps))
}
sims[[1]]@ddf.analyses
sims[[1]]@ddf.analyses$CRITERIA
sims[[1]]@ddf.analyses$criteria
sims[[1]]@ddf.analyses[]$criteria
sims[[1]]@ddf.analyses[1]$criteria
sims[[1]]@ddf.analyses
sims[[1]]@ddf.analyses[[1]]$criteria
sims[[1]]@ddf.analyses[[1]]
sims[[1]]@ddf.analyses[[1]]@criteria
extract.info <- function(simulation, info.name){
switch(info.name,
N = simulation@population.description@N,
reps = simulation@reps,
truncation.distance = simulation@ddf.analyses[[1]]@truncation,
n = simulation@results$individuals$summary[1,4,1000],
estimated.abundance = simulation@results$individuals$N[1,1,1000],
mean.se = simulation@results$individuals$N[1,2,1000],
percentage.bias = 100*((simulation@results$individuals$N[1,1,1000]
- simulation@population.description@N)
/simulation@population.description@N),
RMSE = sqrt(sum((simulation@results$individuals$N[1,1,1:simulation@reps]
- simulation@population.description@N)**2)/simulation@reps))
criteria = simulation@ddf.analyses[[1]]@criteria
}
extract.info(sims[[4]], "criteria")
print(extract.info(sims[[4]], "criteria"))
sims[[1]]@ddf.analyses[[1]]
sims[[1]]@ddf.analyses[[2]]
sims.aic<-sims
save(sims.aic, file = "~/GitHub/DSsim/DSsim/data/truncationResultsAIC.rda")
rm(sims)
rm(sims.aic)
load(file = "~/GitHub/DSsim/DSsim/data/truncationResultsAIC.rda")
load(file = "~/GitHub/DSsim/DSsim/data/truncationResultsBIC.rda")
print(extract.info(sims[[4]], "criteria"))
sims.bic<-sims
print(extract.info(sims.bic[[4]], "criteria"))
save(sims.bic, file = "~/GitHub/DSsim/DSsim/data/truncationResultsBIC.rda")
rm()
rm(*)
rm(*.rda)
rm(**)
rm(sims)
rm(sims.aic)
rm(sims.bic)
rm(extract.info())
rm(extract.info
rm(extract.info)
rm(extract.info)
load(file = "~/GitHub/DSsim/DSsim/data/truncationResults.rda")
sims[[1]]@results$individuals[555]
sims[[1]]@results$individuals
sims[[1]]@results$individuals[1,1,555]
sims[[1]]@results$individuals$N[1,1,555]
sims[[1]]@results$individuals$N[1,1,]
# Chunk 1: setup
library(DSsim)
library(shapefiles)
set.seed(4321)
# Chunk 2: region
region.shapefile <- read.shapefile("Study_ar") #DSsim assumes there is a shapefile called this in the R working directory
region <- make.region(region.name = "Survey Region",
units = "m",
shapefile = region.shapefile)
plot(region)
# Chunk 3: density
pop.density <- make.density(region = region,
x.space = 1000,
y.space = 1000,
constant = 1)
plot(pop.density, plot.units = "m", style = "blocks")
plot(region, add = TRUE)
# Chunk 4: population
pop.description <- make.population.description(region.obj = region,
density.obj = pop.density,
N = 250,
fixed.N = TRUE)
# Chunk 5: detection
sigma = 100
detect <- make.detectability(key.function = "hn",
scale.param = sigma,
truncation = 500)
# Chunk 6: design
parallel.design <- make.design(transect.type = "Line",
design.details = c("Parallel","Systematic"),
region.obj = region,
path = "shapefiles")
# Chunk 7: analyses
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)),
method = "ds",
truncation = 125)
# Chunk 8: analyses2
ddf.analyses.aic <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1), ~cds(key = "hr", formula = ~1)),
method = "ds",
criteria = "AIC",
truncation = 125)
# Chunk 9: make.sim
simtrunc125 <- make.simulation(reps = 999,
single.transect.set = FALSE,
region.obj = region,
design.obj = parallel.design,
population.description.obj = pop.description,
detectability.obj = detect,
ddf.analyses.list = ddf.analyses)
# Chunk 10: gen.pop
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 11: gen.transects
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 12: survey
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 13: dist.data
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 14: first.sim
set.seed(4321)
simtrunc125 <- run(simtrunc125)
setwd("~/GitHub/DSsim/DSsim/vignettes")
# Chunk 1: setup
library(DSsim)
library(shapefiles)
set.seed(4321)
# Chunk 2: region
region.shapefile <- read.shapefile("Study_ar") #DSsim assumes there is a shapefile called this in the R working directory
region <- make.region(region.name = "Survey Region",
units = "m",
shapefile = region.shapefile)
plot(region)
# Chunk 3: density
pop.density <- make.density(region = region,
x.space = 1000,
y.space = 1000,
constant = 1)
plot(pop.density, plot.units = "m", style = "blocks")
plot(region, add = TRUE)
# Chunk 4: population
pop.description <- make.population.description(region.obj = region,
density.obj = pop.density,
N = 250,
fixed.N = TRUE)
# Chunk 5: detection
sigma = 100
detect <- make.detectability(key.function = "hn",
scale.param = sigma,
truncation = 500)
# Chunk 6: design
parallel.design <- make.design(transect.type = "Line",
design.details = c("Parallel","Systematic"),
region.obj = region,
path = "shapefiles")
# Chunk 7: analyses
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)),
method = "ds",
truncation = 125)
# Chunk 8: analyses2
ddf.analyses.aic <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1), ~cds(key = "hr", formula = ~1)),
method = "ds",
criteria = "AIC",
truncation = 125)
# Chunk 9: make.sim
simtrunc125 <- make.simulation(reps = 999,
single.transect.set = FALSE,
region.obj = region,
design.obj = parallel.design,
population.description.obj = pop.description,
detectability.obj = detect,
ddf.analyses.list = ddf.analyses)
# Chunk 10: gen.pop
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 11: gen.transects
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 12: survey
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 13: dist.data
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 14: first.sim
set.seed(4321)
simtrunc125 <- run(simtrunc125)
summary(simtrunc125)
