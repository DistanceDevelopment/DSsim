}else{
RMSE.N = apply(cbind(object@results$clusters$N[, "Estimate", 1:reps], true.N.clusters), 1, calc.RMSE, reps = reps)
RMSE.D = apply(cbind(object@results$clusters$D[, "Estimate", 1:reps], true.D.clusters), 1, calc.RMSE, reps = reps)
}
cluster.summary <- data.frame(mean.Cover.Area = object@results$clusters$summary[,"CoveredArea","mean"],
mean.Effort = object@results$clusters$summary[,"Effort","mean"],
mean.n = object@results$clusters$summary[,"n","mean"],
no.zero.n = zero.n,
mean.k = object@results$clusters$summary[,"k","mean"],
mean.ER = object@results$clusters$summary[,"ER","mean"],
mean.se.ER = object@results$clusters$summary[,"se.ER","mean"],
sd.mean.ER = object@results$clusters$summary[,"ER","sd"])
cluster.N <- data.frame(Truth = true.N.clusters,
mean.Estimate = object@results$clusters$N[,"Estimate","mean"],
percent.bias = (object@results$clusters$N[,"Estimate","mean"] - true.N.clusters)/true.N.clusters*100,
RMSE = RMSE.N,
#lcl = object@results$clusters$N[,"lcl","mean"],
#ucl = object@results$clusters$N[,"ucl","mean"],
CI.coverage.prob = percent.capture/100,
mean.se = object@results$clusters$N[,"se","mean"],
sd.of.means = object@results$clusters$N[,"Estimate","sd"])
cluster.D <- data.frame(Truth = true.D.clusters,
mean.Estimate = object@results$clusters$D[,"Estimate","mean"],
percent.bias = abs(object@results$clusters$D[,"Estimate","mean"] - true.D.clusters)/true.D.clusters*100,
RMSE = RMSE.D,
#lcl = object@results$clusters$N[,"lcl","mean"],
#ucl = object@results$clusters$N[,"ucl","mean"],
CI.coverage.prob = percent.capture.D/100,
mean.se = object@results$clusters$D[,"se","mean"],
sd.of.means = object@results$clusters$D[,"Estimate","sd"])
expected.size <- data.frame(Truth = true.expected.s,
mean.Expected.S = object@results$expected.size[,"Expected.S","mean"],
percent.bias = abs(true.expected.s - object@results$expected.size[,"Expected.S","mean"])/true.expected.s*100,
mean.se.ExpS = object@results$expected.size[,"se.Expected.S","mean"],
sd.mean.ExpS = object@results$expected.size[,"Expected.S","sd"])
clusters <- list(summary = cluster.summary, N = cluster.N, D = cluster.D)
}
detection <- data.frame(mean.observed.Pa = object@results$Detection[,"True.Pa","mean"],
mean.estimate.Pa = object@results$Detection[,"Pa","mean"],
sd.estimate.Pa = object@results$Detection[,"Pa","sd"],
mean.ESW = object@results$Detection[,"ESW","mean"],
sd.ESW = object@results$Detection[,"ESW","sd"])
#Find how many iterations failed
no.fails <- length(which(is.na(object@results$Detection[1,1,1:object@reps])))
#print(individual.N.est)
individuals <- list(summary = individual.summary, N = individual.N, D = individual.D)
#Model selection table
tab.model.selection <- table(object@results$Detection[,"SelectedModel",1:object@reps])
#Create detectabilty summary
detectability.summary <- list(key.function = object@detectability@key.function, scale.param = object@detectability@scale.param, shape.param = object@detectability@shape.param, truncation = object@detectability@truncation)
#Create analysis summary
analysis.summary <- list(dsmodels = list(), criteria = object@ddf.analyses[[1]]@criteria, truncation = object@ddf.analyses[[1]]@truncation)
#Create design summary
design.type <- switch(class(object@design),
LT.Systematic.Design = "Systematic Parallel Line Transect",
LT.EqAngle.ZZ.Design = "Equal Angle Zigzag Line Transect",
LT.EqSpace.ZZ.Design = "Equal Spaced Zigzag Line Transect",
LT.Random.Design = "Random Parallel Line Transect",
LT.User.Specified.Design = "Subjective Line Transect",
PT.Systematic.Design = "Systematic Point Transect",
PT.Nested.Design = "Systematic Nested Point Transect",
PT.Random.Design = "Random Point Transect",
LT.SegmentedTrack.Design = "Segmented Track Line Transect",
LT.SegmentedGrid.Design = "Segmented Grid Line Transect")
slots <- slotNames(object@design)
design.parameters <- list()
count <- 1
for(i in seq(along = slots)){
if(slots[i] %in% c("design.axis", "spacing", "plus.sampling", "nested.space")){
if(!(slot(object@design, slots[i]) == numeric(0))){
design.parameters[[slots[i]]] <- slot(object@design, slots[i])
}
}
}
design.summary <- new(Class = "Design.Summary", design.type = design.type, design.parameters = design.parameters)
#Create population summary
if(object@ddf.analyses[[1]]@binned.data){
analysis.summary$cutpoints <- object@ddf.analyses[[1]]@cutpoints
}
if(nrow(analysis.strata) > 0){
analysis.summary$analysis.strata <- object@ddf.analyses[[1]]@analysis.strata
}
for(i in seq(along = object@ddf.analyses)){
analysis.summary$dsmodels[[i]] <- object@ddf.analyses[[i]]@dsmodel
}
if(!is.null(object@results$clusters)){
summary.x <- new(Class = "Simulation.Summary", region.name = object@region@region.name, total.reps = object@reps, failures = no.fails, individuals = individuals, clusters = clusters, expected.size = expected.size, detection = detection, model.selection = tab.model.selection, design.summary = design.summary, detectability.summary = detectability.summary, analysis.summary = analysis.summary)
}else{
summary.x <- new(Class = "Simulation.Summary", region.name = object@region@region.name, total.reps = object@reps, failures = no.fails, individuals = individuals, detection = detection, model.selection = tab.model.selection, design.summary = design.summary, detectability.summary = detectability.summary, analysis.summary = analysis.summary)
}
return(summary.x)
}
)
#' show
#'
#' Not currently implemented
#'
#' @param object object of class Simulation
#' @rdname show.Simulation-methods
#' @export
setMethod(
f="show",
signature="Simulation",
definition=function(object){
message("show not currently implemented")
invisible(object)
}
)
#' histogram.N.ests
#'
#' Plots a histogram of the estimates abundances
#'
#' @param x object of class Simulation
#' @param ... optional parameters to pass to the generic hist function in graphics
#' @rdname histogram.N.ests-methods
#' @importFrom graphics hist abline
#' @export
histogram.N.ests <- function(x, ...){
reps <- x@reps
index <- dim(x@results$individuals$N)[1]
true.N <- sum(x@population.description@N)
if(!is.null(x@results$clusters)){
ests <- x@results$clusters$N[index, "Estimate", 1:reps]
hist(ests, main = "Histogram of Estimates", xlab = "Estimated Abundance of Clusters", ...)
}else{
ests <- x@results$individuals$N[index, "Estimate", 1:reps]
hist(ests, main = "Histogram of Estimates", xlab = "Estimated Abundance of Individuals", ...)
}
abline(v = true.N, col = 2, lwd = 3, lty = 2)
invisible(x)
}
# @rdname Simulation-class
# @export
#setMethod(
#  f="plot",
#  signature="Simulation",
#  definition=function(x, ...){
#    message("not currently implemented")
#    invisible(x)
#  }
#)
#' @rdname generate.population-methods
#' @export
setMethod(
f="generate.population",
signature="Simulation",
definition=function(object, ...){
population <- generate.population(object = object@population.description, detectability = object@detectability, region.obj = object@region)
return(population)
}
)
#' @rdname generate.transects-methods
#' @export
setMethod(
f="generate.transects",
signature="Simulation",
definition=function(object, read.from.file = TRUE, write.to.file = FALSE, region = NULL){
region <- object@region
transect <- generate.transects(object@design, region = region)
return(transect)
}
)
#' @rdname create.survey.results-methods
#' @export
setMethod(
f="create.survey.results",
signature="Simulation",
definition=function(object, dht.tables = FALSE, ...){
population <- generate.population(object)
transects  <- generate.transects(object)
if(object@double.observer){
#move this to the checking of the simulation object
message("Double observer simulations not supported at present")
}else{
if(inherits(object@design, "LT.Design")){
survey <- new(Class = "Single.Obs.LT.Survey", population = population, line.transect = transects, perp.truncation = object@detectability@truncation)
}else if(inherits(object@design, "PT.Design")){
survey <- new(Class = "Single.Obs.PT.Survey", population = population, point.transect = transects, rad.truncation = object@detectability@truncation)
}
}
survey.data <- create.survey.results(object = survey, dht.tables = dht.tables, region = object@region)
ddf.data <- survey.data$ddf.data
if(dht.tables){
obs.table <- survey.data$obs.table
sample.table <- survey.data$sample.table
region.table <- survey.data$region.table
survey.results <- new(Class = "Survey.Results", region = object@region, population = population, transects = transects, ddf.data = ddf.data, obs.table = obs.table, sample.table = sample.table, region.table = region.table)
}else{
obs.table <- new(Class = "Obs.Table")
sample.table <- new(Class = "Sample.Table")
region.table <- new(Class = "Region.Table")
survey.results <- new(Class = "Survey.Results", region = object@region, population = population, transects = transects, ddf.data = ddf.data, obs.table = obs.table, sample.table = sample.table, region.table = region.table)
}
return(survey.results)
}
)
#' @rdname run.analysis-methods
#' @export
setMethod(
f="run.analysis",
signature=c("Simulation","Survey.Results"),
definition=function(object, data, dht = FALSE){
#dist.data <- survey.results@ddf.data
best.model <- run.analysis(object, data@ddf.data)
#If dht is true but tables have not been provided
if(dht & nrow(data@region.table@region.table) == 0){
warning("dht tables have not been provided please re-run create.survey.results with dht.tables = TRUE if you would like density/abundance estimates in addition to ddf results.", immediate. = TRUE, call. = FALSE)
dht = FALSE
}
#If ddf has converged and dht it TRUE
if(dht & !is.null(best.model)){
#Calculate density/abundance
dht.results <- dht(best.model, data@region.table@region.table, data@sample.table@sample.table, data@obs.table@obs.table)
return(list(ddf = best.model, dht = dht.results))
}
return(list(ddf = best.model))
}
)
#' @rdname run.analysis-methods
#' @importFrom stats na.omit
#' @export
setMethod(
f="run.analysis",
signature=c("Simulation","DDF.Data"),
definition=function(object, data, dht = FALSE){
ddf.analyses <- object@ddf.analyses
criteria <- NULL
results <- list()
point <- inherits(object@design, "PT.Design")
for(a in seq(along = ddf.analyses)){
results[[a]] <- run.analysis(ddf.analyses[[a]], data, point = point)
if(!is.na(results[[a]][1])){
#Get information to calculate selection criteria
lnl <- results[[a]]$lnl
k <- length(results[[a]]$par)
n <- nrow(results[[a]]$data)
criterion <- object@ddf.analyses[[1]]@criteria
selection.criterion.value <- switch(criterion,
AIC  = 2*k-2*lnl,
aic  = 2*k-2*lnl,
AICc = 2*k-2*lnl+(2*k*(k+1))/(n-k-1),
BIC  = k*log(n)-2*lnl,
bic  = k*log(n)-2*lnl)
criteria <- c(criteria, selection.criterion.value)
}else{
criteria <- c(criteria, NA)
}
}
#check that at least one model worked
no.successful.models <- length(which(!is.na(criteria)))
if(no.successful.models > 0){
best.model.index <- which(criteria == min(na.omit(criteria)))
best.model <- results[[best.model.index]]
best.model$model.index <- best.model.index
#If there is more than one sucessful model find the delta criteria to the
#second best model.
if(no.successful.models > 1){
sorted.criteria <- sort(criteria, na.last = NA)
delta.criteria <- sorted.criteria[2] - sorted.criteria[1]
best.model$delta.criteria <- delta.criteria
}
return(best.model)
}else{
return(NULL)
}
}
)
#' @rdname run-methods
#' @importFrom parallel detectCores makeCluster clusterEvalQ parLapply stopCluster
#' @export
setMethod(
f="run",
signature="Simulation",
definition=function(object, run.parallel = FALSE, max.cores = NA, save.data = FALSE, load.data = FALSE, data.path = character(0)){
#Note options save.data, load.data, data.path are not implemented in simulations run in parallel.
#check the data.path ends in "/"
if(length(data.path) > 0){
temp.path <- strsplit(data.path, split = "")
if(temp.path[length(temp.path)] != "/"){
data.path <- paste(data.path, "/", sep = "")
}
rm(temp.path)
}
#set the transect index to 1
orig.file.index <- object@design@file.index
object@design@file.index <- 1
if(run.parallel & requireNamespace('parallel', quietly = TRUE)){
# counts the number of cores you have
nCores <- getOption("cl.cores", detectCores())
if(!is.na(max.cores)){
nCores <- min(nCores - 1, max.cores)
}
# intitialise the cluster
myCluster <- makeCluster(nCores)
clusterEvalQ(myCluster, {
require(DSsim)
})
results <- parLapply(myCluster, X = as.list(1:object@reps), fun = single.simulation.loop, object = object, save.data = save.data, load.data = load.data, data.path = data.path)
object <- accumulate.PP.results(simulation = object, results = results)
stopCluster(myCluster)
}else{
#Check that it wasn't trying to run parallel
if(run.parallel){
warning("Could not run in parallel, library(parallel) is not installed.")
}
#otherwise loop
for(i in 1:object@reps){
object@results <- single.simulation.loop(i, object, save.data = save.data, load.data = load.data, data.path = data.path)
}
}
object@results <- add.summary.results(object@results)
object@design@file.index <- orig.file.index
return(object)
}
)
library(DSsim)
summary(sim.trunc125.aic.hnhr)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
summary(sim.trunc125.aic.hnhr)
summary(sim, include.glossary=FALSE)
sim.trunc125.aic.hnhr@results$individuals$N
sim.trunc125.aic.hnhr@results$individuals$summary
sim.trunc125.aic.hnhr@results
sim.trunc125.aic.hnhr@results$Detection
sim.trunc125.aic.hnhr@results
sim.trunc125.aic.hnhr@results$individuals
sim.trunc125.aic.hnhr@results$individuals$N
sim.trunc125.aic.hnhr@results$individuals$N[1,,]
sim.trunc125.aic.hnhr@results$individuals$N[1,,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,4,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,5,1000]
sim.trunc125.aic.hnhr@results$individuals$N[1,1,1000]
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
sim.trunc125.aic.hnhr
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc150AIChnhr.robj")
length(sim.trunc125.aic.hnhr@results$individuals$N[1,1,1:999])
summary(sims[[1]])
summary(sims[[1]])```
??ggplot
install.packages("ggplot2")
data = data.frame(truncation = c(125, 150, 175, 200, 250, 300), estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999])
)
?stat_summary
library(DSsim)
library(ggplot2)
data = data.frame(truncation = factor(rep(c(125, 150, 175, 200, 250, 300), each=999)), estimates = c(sims[[1]]@results$individuals$N[1,1,1:999], sims[[2]]@results$individuals$N[1,1,1:999], sims[[3]]@results$individuals$N[1,1,1:999], sims[[4]]@results$individuals$N[1,1,1:999], sims[[5]]@results$individuals$N[1,1,1:999], sims[[6]]@results$individuals$N[1,1,1:999]))
ggplot(data, aes(x = truncation, y = estimates))
+ geom_boxplot()
+ geom_hline(yintercept = 250, linetype="dashed", color = "red", size = 1.2)
+ stat_summary(fun.y = mean, geom="point", size = 2, color = "blue")
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
library(DSsim)
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc150AIChnhr.robj")
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc125aichnhr.robj")
load("C:/Users/kiera/Dropbox/Kieran Studenship/NewResultsJuly/simtrunc1775AIChnhr.robj")
sims<-vector("list", length=2)
sims[[1]] <- sim.trunc125.aic.hnhr
sims[[2]] <- sim
extract.trun.dist <- function(simulation){
return(simulation@ddf.analyses[[1]]@truncation)
}
Trunc.Dist = extract.trun.dist(sims)
?lapply
Trunc.dist <- lapply(sims, extract.trun.dist)
# Chunk 1
library(DSsim)
library(shapefiles)
set.seed(321)
# Chunk 2
region.shapefile <- read.shapefile("Study_ar")
region <- make.region(region.name = "Survey Region", units = "m", shapefile = region.shapefile)
plot(region)
# Chunk 3
pop.density <- make.density(region = region, x.space = 1000, y.space = 1000, constant = 1)
plot(pop.density, plot.units = "km", style = "blocks")
plot(region, add = TRUE)
# Chunk 4
pop.description <- make.population.description(region.obj = region, density.obj = pop.density, N = 250, fixed.N = TRUE)
# Chunk 5
detect <- make.detectability(key.function = "hn", scale.param = 100, truncation = 500)
# Chunk 6
parallel.design <- make.design(transect.type = "Line",design.details = c("Parallel","Systematic"),region.obj = region, path = "shapefiles")
# Chunk 7
sigma = 100
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = 125)
# Chunk 8
simtrunc125 <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
# Chunk 9
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 10
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 11
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 12
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 13
simtrunc125 <- run(simtrunc125)
setwd("~/GitHub/DSsim/DSsim/vignettes")
# Chunk 1
library(DSsim)
library(shapefiles)
set.seed(321)
# Chunk 2
region.shapefile <- read.shapefile("Study_ar")
region <- make.region(region.name = "Survey Region", units = "m", shapefile = region.shapefile)
plot(region)
# Chunk 3
pop.density <- make.density(region = region, x.space = 1000, y.space = 1000, constant = 1)
plot(pop.density, plot.units = "km", style = "blocks")
plot(region, add = TRUE)
# Chunk 4
pop.description <- make.population.description(region.obj = region, density.obj = pop.density, N = 250, fixed.N = TRUE)
# Chunk 5
detect <- make.detectability(key.function = "hn", scale.param = 100, truncation = 500)
# Chunk 6
parallel.design <- make.design(transect.type = "Line",design.details = c("Parallel","Systematic"),region.obj = region, path = "shapefiles")
# Chunk 7
sigma = 100
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = 125)
# Chunk 8
simtrunc125 <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
# Chunk 9
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 10
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 11
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 12
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 13
simtrunc125 <- run(simtrunc125)
simtrunc125@results$individuals$N[1,1,1:999]
# Chunk 1
library(DSsim)
library(shapefiles)
set.seed(321)
# Chunk 2
region.shapefile <- read.shapefile("Study_ar")
region <- make.region(region.name = "Survey Region", units = "m", shapefile = region.shapefile)
plot(region)
# Chunk 3
pop.density <- make.density(region = region, x.space = 1000, y.space = 1000, constant = 1)
plot(pop.density, plot.units = "km", style = "blocks")
plot(region, add = TRUE)
# Chunk 4
pop.description <- make.population.description(region.obj = region, density.obj = pop.density, N = 250, fixed.N = TRUE)
# Chunk 5
detect <- make.detectability(key.function = "hn", scale.param = 100, truncation = 500)
# Chunk 6
parallel.design <- make.design(transect.type = "Line",design.details = c("Parallel","Systematic"),region.obj = region, path = "shapefiles")
# Chunk 7
sigma = 100
ddf.analyses <- make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1)), method = "ds", criteria = "AIC", truncation = 1.25*sigma)
# Chunk 8
simtrunc125 <- make.simulation(reps = 999, single.transect.set = FALSE, region.obj = region, design.obj = parallel.design, population.description.obj = pop.description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
# Chunk 9
pop <- generate.population(simtrunc125)
plot(region)
plot(pop)
# Chunk 10
transects <- generate.transects(simtrunc125)
plot(region)
plot(transects, col = 4, lwd = 2)
# Chunk 11
eg.survey <- create.survey.results(simtrunc125)
plot(eg.survey)
# Chunk 12
dist.data <- get.distance.data(eg.survey)
hist(dist.data$distance, xlab = "Distance (m)", main = "Distance Data")
# Chunk 13
simtrunc125 <- run(simtrunc125)
simtrunc125@results$individuals$N[1,1,1:999]
simtrunc125@results$individuals$N[1,1,555]
summary(simtrunc125)
simtrunc125@results$individuals[1,1,555]
simtrunc125[1,1,555]
simtrunc125
simtrunc125@results
simtrunc125@results[1,1,555]
simtrunc125@results[1,555]
simtrunc125@results[555]
simtrunc125@results[556]
simtrunc125@results[1]
simtrunc125@results$Detection
simtrunc125@results$Detection[1]
simtrunc125@results$Detection[2]
simtrunc125@results$Detection[1,1]
simtrunc125@results$Detection[555]
simtrunc125@results$Detection[556]
simtrunc125@results$Detection[344]
simtrunc125@results$Detection
simtrunc125@results$Detection[1:100]
simtrunc125@results$individuals[,,555]
simtrunc125@results$individuals$N[1,1,555]
simtrunc125@results$individuals$N[1,,555]
simtrunc125@results$individuals$N[,,555]
simtrunc125@results$individuals$summary[,,555]
simtrunc125@results$individuals$summary[,,555]
