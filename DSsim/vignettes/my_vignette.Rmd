---
title: "Vignette"
author: "Kieran Richards"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

#An Overview of DSsim : Distance Sampling Simulation
Distance sampling is a methodology which is often used to estimate the size of an animal population.  Unfortunately the surveys involved are often be time consuming and expensive.  _DSsim_ provides the opportunity to simulate survey designs and spot potential problems early.  The functions in _DSsim_ are made available by running this command:

```{r setup, message=FALSE, warning=FALSE}
library(DSsim)
```

There are several important functions that can be used when solving a problem with _DSsim_.  These are _make.region_, _make.density_, _make.population.description_, _make.detectability_, _make.design_, _make.ddf.analysis.list_ and _make.simulation_.  All of these are required to successfully build and run a simulation with _DSsim_ and each is described in detail here.

#The Functions
##_make.region_
This function is used to create a region object.  Region objects describe the shape and dimensions of the region as well as any gaps in the region.  There are two ways of using _make.region_ to create a region object.  The first is by passing a list of coordinates to the _coords_ and _gaps_ arguments and is shown in our example.  The second is by passing a previously constructed shapefile to the _shapefile_ argument.


###The Arguments of the _make.region_

_region.name_
    : This argument is required and specifies the name of the region

_strata.name_
    : This argument is used to specify the name of the stratum and is used when a region consists of multiple strata

_units_
    : The units used for the distances in the region given as a character, usually "m" or "km"

_area_
    : The area of the region, if this is omitted then it will be calculated

_shapefile_
    : A shapefile detailing the region

_coords_
    : If a shapefile is not given then coords must be; 
      a list of polygons which describes the shape of the region

_gaps_
    : If a shapefile is not given then coords must be;
      a list of polygons which describes the shape of the region


###An Example
```{r region.example}
#Firstly create lists to contain the polygon information for coords and gaps
coords <- gaps <- list()
#Fill the lists, making sure to "close" each polygon by setting the last coordinate pair equal to the first
coords[[1]] <- list(data.frame(x = c(0,1000,1000,0,0), y = c(0,0,
 1000,1000,0)))
gaps[[1]] <- list(data.frame(x = c(400,600,500,350,400), y = c(100,
 250,600,120,100)))
#Call make.region and store the result to a variable
region <- make.region(region.name = "study.area", units = "m", 
 coords = coords, gaps = gaps)
#Plot the region
plot(region)
```

As you can see the output is a rectangle with corners at the points given in _coords_ and a polygon removed with corners at the coordinates given in _gaps_.

##_make.density_
_make.density_ is used to create density objects.  Density objects describe how a population is distributed across a region.  There are three ways in which _make.density_ can be used to create a density object.  The first is by supplying a _density.surface_ which is a list of data.frames with columns _x_,_y_, and _density_.  The second is by passing a value for the _constant_ argument which will produce a density object with the same density everywhere and the last is by providing a _mgcv gam_ object which will be used to produce the grid.  Additionally, the density object may be edited by using the _add.hotspot_ method to add Gaussian hills to the object.

###The arguments of _make.density_

_region.obj_
    : This argument is required and specifies the Region object in which the density grid will be created

_density.surface_
    : A list of data.frames with columns _x_,_y_, and _density_, there must be one data.frame per strata

_x.space_
    : This argument is required and specifies the intervals in the grid in the x direction

_y.space_
    : This argument is required and specifies the intervals in the grid in the y direction

_constant_
    : Provides a value for a constant density across the region

_density.gam_
    : A _gam_ object created using _mgcv_


###The arguments of _add.hotspot_

_object_
    : A density or simulation object

_centre_
    : An x,y-coordinate giving the centre of the hotspot

_sigma_
    : A value giving the scale parameter for a Gaussian decay

_amplitude_
    : The height of the hotspot at its centre


##An Example Using Constant Density
```{r density.example.1}
#Create the density object and store it to a variable
density = make.density(region.obj = region, x.space = 10, y.space = 10, constant = 0.5)
#Add some hotspots
density = add.hotspot(object = density, centre = c(50,200), sigma = 100, amplitude = 0.1)
density = add.hotspot(object = density, centre = c(500,700), sigma = 900, amplitude = 0.05)
density = add.hotspot(object = density, centre = c(300,100), sigma = 100, amplitude = -0.15)
```

```{r, density.example.2.setup, echo=FALSE, results='hide'}
surface = density@density.surface
```
##An Example Using a Density Surface
```{r density.example.2}
#Create the density object using a density surface and store it to a variable
density = make.density(region.obj = region, density.surface = surface, x.space = 10, y.space = 10)

#Plot the region density
plot(density)
```

The surface used in the second example was obtained by extracting the density.surface attribute of the density object created in the first example however any list of a data.frame with columns _x_,_y_, and _density_ could have been used.  The plot shows that there are Gaussian decays at the points (50,200), (500,700) and (300,100) where the hotspots were added.

##_make.population.description_
_make.population.description_ is used to create a descriptor of the population.  The object created by _make.population.description_ will be used to generate the population. 

_clusters?_

###The arguments of _make.population.description_

_region.obj_
    : This argument is required and specifies the region object which describes the shape of the region in which the population is located

_density.obj_
    : This argument is also required and specifies the density object which describes how the population should be distributed in the region

_cluster.size.table_
    : __?__ Not required.

_N_
    : The number of individuals/clusters in the region

_fixed.N_
    : A TRUE/FALSE value which defaults to TRUE.  If TRUE the population is generated from N, otherwise it is generated from the density description

###An Example
```{r}
description = make.population.description(N=1000, density.obj = density, region.obj = region, fixed.N = TRUE)
```

##_make.detectability_

_make.detectability_ creates a detectability function which describes the probability of detecting an individual from the population given its perpendicular distance from the transect.  _make.detectability_ can either create a detectability function using a half normal distribution or a hazard rate distribution.

###The arguments of _make.detectability_

_key.function_
    : specifies shape of the detection function (either half-normal "hn" or hazard rate "hr" or uniform "uf")

_scale.param_
    : parameter value

_shape.param_
    : parameter value

_truncation_
    : the maximum perpendicular distance at which objects may be from a transect and still be detectable.

###An Example
```{r}
detect = make.detectability(key.function = "hn", scale.param = 15, truncation = 30)
```

##_make.design_
Currently surveys can only be generated using the __Distance__ software.  If you are running a simulation in R you will need to use __Distance__ to generate all the surveys as shapefiles and tell R which directory contains these shapefiles in the path argument.

**Note**: This directory must contain only the shapefiles that you wish to use and nothing else

The _design.details_ argument should specify the details of the design and the options are given in the following table:

|Transect Type|   Design Details   |
|:-----------:|:------------------:|
|Line         |Parallel, Systematic|
|Line         |Parallel, Random    |
|Line         |Zigzag, Equal Angle |
|Line         |Zigzag, Equal Spaced|
|Line         |User Specified      |
|Point        |Systematic          |
|Point        |Random              |

###The arguments of _make.design_

_transect.type_
    : Required and must be from the above table

_design.details_
    : Required and must be from the above table
    
_region.obj_
    : Specifies the region in which the survey is to be carried out

_design.axis_
    : User may provide the angle of the design axis but not currently used

_spacing_
    : User may provide the systematic design spacing but but not currently used

_angle_
    : User may provide the design angle (only relevant in equal angle zigzag designs) but not currently used

_plus.sampling_
    : TRUE/FALSE; if TRUE a plus sampling protocol is used but not currently used

_path_
    : The location of the directory which contains the shapefiles

###An Example
```{r eval=FALSE}
parallel.design = make.design(transect.type = "Line", design.details = c("Parallel", "Systematic"), region = region, design.axis = 0, spacing = 100, plus.sampling = FALSE, path = "C:/...")
```
##_make.ddf.analysis.list_
_make.ddf.analysis.list_ is used to create a list of models which the simulation will fit to the data generated by the simulation.  The model with the minimum criteria value will be selected when the simulation is run.

###The arguments of _make.ddf.analysis.list_

_dsmodel_
    : A list of distance sampling model formula specifying the detection function (see ?ddf for further details)

_method_
    : currently only "ds" normal distance sampling has been implemented

_criteria_
    : Specifies the model selection criteria; can be AIC, AICc or BIC

_analysis.strata_
    : Dataframe with two columns ("design.id" and "analysis.id"). The former gives the strata names as defined in the design (i.e. the region object) the second specifies how they should be grouped (into less strata) for the analyses

_truncation_
    : Specifies the truncation distance for the analysis of the models

_binned.data_
    : A TRUE/FALSE value.  If TRUE the data will be analysed in bins

_cutpoints_
    : Specifies the cutpoints for binning the data

###An Example
```{r}
ddf.analyses = make.ddf.analysis.list(dsmodel = list(~cds(key = "hn", formula = ~1), ~cds(key = "hr", formula = ~1)), method = "ds", criteria = "AIC")
```

##_make.simulation_
_make.simulation_ is used to bundle together all the objects that are required to run the simulation.

###The arguments of _make.simulation_

_reps_
    : The number of times the simulation should be repeated

_single.transect.set_
    : TRUE/FALSE value; if TRUE the same set of transects will be used throughout the simulations. Defaults to FALSE

_region.obj_
    : A region object that has been made with _make.region_

_design.obj_
    : A design object which has been made with _make.design_

_population.description.obj_
    : A population description object which has been made with _make.population.description_

_detectability.obj_
    : A detectability object which has been made with _make.detectability_

_ddf.analyses.list_
    : A list of DDF Analysis objects which has been made with _make.ddf.analysis.list_

###An Example
```{r eval=FALSE}
simulation = make.simulation(reps = 10, region.obj = region, design.obj = parallel.design, population.description.obj = description, detectability.obj = detect, ddf.analyses.list = ddf.analyses)
```

##Running the simulation
Now that the simulation has been made it needs to run.  This can take a long time, especially if reps is a large number.

```{r eval=FALSE}
simulation.results = run(simulation)
```

The results can then be viewed in a summary table

```{r eval=FALSE}
summary(simulation.results)
```